# 类加载机制

### 初始化
初始化阶段在真正开始执行类中定义的Java字节码。**初始化阶段是执行类构造器`<clinit>()`方法的过程，该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的**。<br>
##### 静态语句块的变量访问
编译器收集顺序是语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中**可以赋值，但不能访问**。
```java
public class Test {
	static {
		i = 0;						// 给变量赋值可以正常编译通过
		System.out.println(i);		// 编译失败，“非法向前引用”
	}
	static int i = 1;
}
```
`<clinit>()`方法与类的构造器（或者说实例构造器`<init>()`方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕，因此虚拟机中第一个被执行的<clinit>()方法的类肯定是`java.lang.Object`。而且父类中定义的静态语句块要优先于子类的赋值操作。<br>

`<clinit>()`方法对类和接口不是必须的，在没有静态语句块与类变量的赋值操作的情况下，可以不为这个类生成`<clinit>()`方法。
接口中不能使用静态语句块，但任然有变量的赋值操作。但接口与类不同的是，**执行接口的`<clinit>()`不需要先执行父接口的`<clinit>()`方法**，接口的实现类在初始化时也一样不会执行接口的`<clinit>()`方法。**只有当父接口中定义的变量使用时，父接口才会初始化。<br> 

如果有多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的`<clinit>()`方法，其他线程都需要**阻塞等待**，直到活动线程执行`<clinit>()`方法完毕。其他线程唤醒后不会再次进入<clinit>()方法。
**同一个类加载器下，一个类型只会初始化一次。**

## 类加载器
类加载器一个代码模块，它实现了一个动作：``通过一个类的全限定域名来获取一个类的字节流``。它是唯一一个类加载阶段用户可以通过自定义类加载器参与进来的一个阶段。<br>

##### 1. 类与类加载器
对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，*每一个类加载器，都拥有一个独立的类名称空间。
通俗点讲就是：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，
被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。
> 这里的“相等”指的是代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法返回的结果，也包括使用instanceof关键字做对象所属关系判定等情况。

##### 2. 双亲委派模型
如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此**所有的加载请求最终都应该传送到顶层的启动类加载器中**，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。<br>

从虚拟机角度讲，只存在两种不同类型的类加载器：<br>
1. 启动类加载器（`Bootstrap ClassLoader`）：它是虚拟机本身的一部分，在HotSpot中，由C++语言实现。
2. 所有的其他类加载器：独立于虚拟机外部，都继承自抽象类`java.lang.ClassLoader`

###### 双亲委派模型的破坏
双亲委派模型解决了各个类加载器的统一问题（最基础的代码由Bootstrap类加载器加载），但如果基础类又要调用回用户的代码，那就必须得想别的办法了。
1. 比如Java有些服务需要调用由独立厂商实现并部署在应用程序的ClassPath下的SPI（`Service Provider Interface`）的代码，启动类加载器不可能“认识”这些代码。
> JNDI、JDBC  
为了解决这些问题，引入了线程上下文类加载器（`Thread Context ClassLoader`）。为了得到需要的SPI代码，父类加载器会请求子类加载器去完成类加载的动作。
2. OSGi代码热替换：每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。
