# JVM字节码执行引擎
> 跨平台，外观一致性：输入字节码，字节码解析，输出执行结果  
1. 解释执行（通过解释器）
2. 编译执行（通过即时编译器产生本地代码执行）

### 一. 栈帧
栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是运行时数据区中虚拟机栈的栈元素。
在活动线程中，只有位于栈顶的栈帧才是有效的，执行引擎运行的所有字节码指令都只针对当前栈帧（栈顶的）进行操作。
> 虚拟机栈是线程私有的，不会出现数据安全问题；  
> 在编译程序编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写到了方法表的Code属性当中，
> 因此**一个栈帧需要分配多少内存，不会受到运行期变量数据的影响，而仅仅取决于具体的虚拟机实现**。

下面是一个栈帧中的内容有：<br>

##### 1. 局部变量表:<br>
用于存放方法参数和方法内部定义的局部变量的空间，它以变量槽（`Slot`）为基本单位，目前主流的一个Slot占32位，虚拟机规范指出
**每一个Slot应该能放下boolean、byte、char、short、int、float、reference或returnAddress类型的数据**

对于两个相邻的共同存放一个64位数据（long、double）的两个Slot，虚拟机不允许采用任何方式单独访问其中的某一个。0号Slot默认是用于传递
方法所属对象实例的引用，在方法中可以通过关键字this来访问这个隐含的参数。

这里说下reference的作用：<br>
  2. 虚拟机应该能从此引用直接或间接地查找到对象**在Java堆中的数据的起始地址索引**。
  2. 虚拟机应该能从此引用直接或间接地查找到对象**所属数据类型在方法中存储的类型信息**。  

最后一种returnAddress现在基本不用了，它是为jsr、jsr_w、和ret服务的，而这几条指令现在已经不用了。

###### Slot重用与GC的关系
方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用<br>
在方法体中，一个对象能否被回收的根本原因是：局部变量表中的Slot是否还存在者关于该对象的引用。

综合前面两句话，即使一个引用超出了作用域，但没有一个新值来使用掉它的这个Slot，那么这个引用就一直在局部变量表里，是不会被GC的。
```java
public static void main()(String[] args) {
	{
		byte[] placeholder = new byte[64 * 1024 * 1024];
	}
	int a = 0;              // 这里placeholder已经离开了作用域，如果没有新值来占位，它就无法被回收
	// placeholder = null   // 也可以
	System.gc();
}
```
有一条编码规则是这样讲的：`不使用的对象应手动赋值为null`。但赋值null的操作容易被编译器优化掉，而且做到这一步的编译器也能很好的处理回收的问题。

##### 2. 操作数栈
同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的`max_stacks`数据项中。Java“基于栈的执行引擎”中的**栈**指的就是操作数栈。
> 栈帧和操作数栈都是栈结构，不要搞混了。

类校验阶段的数据流分析，会验证操作数栈中元素的数据类型一定与字节码指令的序列严格匹配。

在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但大多数虚拟机的实现里会下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在
一起，以便在执行方法调用的时候共用一部分数据，无需额外的参数复制传递。

##### 3. 动态链接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

##### 4. 方法返回地址
当一个方法开始执行后，只有两种方式可以退出这个方法：<br>
1. 正常完成出口：执行引擎遇到任意一个方法返回的字节码指令，此时调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个值
1. 异常完成出口：在方法执行遇到了异常，并且这个异常没有在方法体内得到处理<br>
无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的**异常表**内没有搜索到匹配的异常处理器，就会导致方法退出。
**一个方法采用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的**

方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的
操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。


### 二. 方法调用
方法调用不等同于方法执行，方法调用阶段唯一的任务就是**确定被调用方法的版本（即调用哪一个方法）**，暂时还不涉及方法内部的具体运行过程。
> Java天生动态的特性：一切方法调用在Class文件里面存储的都只是**符号引用**，而不是方法在实际运行时内存布局的入口地址（相当于之前说的直接引用）。
> Java的方法调用需要在**类加载期间**，甚至到**运行期间**才能确定目标方法的直接引用。

##### 1. 解析
在类加载的解析阶段，会将一部分符号引用转化为直接引用，这种解析能成立有个前提（`编译期可知，运行期不变`)：
1. 方法在程序真正可运行之前就有一个可确定的调用版本。
1. 这个方法的调用版本在运行期是不可变的。

符合上述要求的方法，主要包括` 静态方法 `和` 私有方法 `两大类，前者与类型直接关联，后者在外部不可访问，这两种方法各自的特性决定了它们都不可能通过继承或
别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。另外还有` 实例构造器 `和` 父类方法（未重写的或super） `也符合上述要求。这四类称为**非虚方法**。<br>
> 非虚方法还包括final方法，但它是由invokevirtual指令来调用的。

**解析调用一定是一个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转化为可确定的直接引用，不会延迟到运行期再去完成**

Java虚拟机提供了5条调用字节码的指令：<br>
1. invokestatic:     调用静态方法
2. invokespecial:    调用实例构造器`<init>()`方法、私有方法和父类方法
3. invokevirtual:    调用所有的虚方法（`除去非虚方法和final方法之外的方法`）
4. invokeinterface:  调用接口方法，会在运行时再确定一个实现此接口的对象
5. invokedynamic:    先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法

前4条调用指令的分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

##### 2. 分派
面向对象的三个基本特征：继承、封装和多态。<br>
与解析调用有差异，分配调用可能是静态的也可能是动态的，多态性特征中的“重载”与“重写”是分派调用过程的结果体现。

###### 1. 静态分派
重载涉及到静态类型与实际类型，虚拟机（准确的说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译器可知的，因此，
在**编译阶段**，Javac编译器会根据参数的静态类型决定使用那个重载版本，一个它认为“最合适”的版本。

所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。静态分派的动作实际上不是由虚拟机来执行的。

解析与分派这两者之间的关系并不是二选一的排他关系，它们是在不同层次上去筛选、确定目标方法的过程。比如静态方法会在类加载期就进行解析，而静态方法
显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的

###### 2. 动态分派
动态分派和多态性的另外一个重要体现——重写有着密切的关系。

invokevirtual指令的堕胎查找过程：<br>
1. 找到操作数栈顶的第一个元素所指向对象的**实际类型**，记作C。
1. 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的**直接引用**，查找过程结束；如果不通过，
则返回java.lang.IllegalAccessError异常。
1. 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
1. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

invokevirtual指令把常量池中的类方法符号引用解析到直接引用的时候，它的第一步就是在运行期确定接收者的实际类型。
